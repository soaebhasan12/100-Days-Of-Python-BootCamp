<p>First, we have to identify if there are any missing or junk values in our DataFrames. </p><h4>Challenge</h4><p>Can you investigate all 4 DataFrames and find if there are any missing values?&nbsp;</p><p>If yes, find how many missing or NaN&nbsp;values there are. Then, find the row where the missing values occur. </p><p>Finally, remove any rows that contain missing values. </p><p>.</p><p>.</p><p>..</p><p>...</p><p>..</p><p>.</p><p>.</p><p><strong>Solution:&nbsp;Finding the missing values</strong></p><p>For 3 of the DataFrames there are no missing values. We can verify this using the <code>.isna()</code> method. This will return a whole series of booleans, but we can chain<code> .values.any()</code> to see if any value in the series is <code>True</code>. </p><pre class="prettyprint linenums">print(f'Missing values for Tesla?: {df_tesla.isna().values.any()}')
print(f'Missing values for U/E?: {df_unemployment.isna().values.any()}')
print(f'Missing values for BTC Search?: {df_btc_search.isna().values.any()}')</pre><p>However, for the Bitcoin price data, there seems to be a problem. There's a missing value somewhere. </p><p>The number of missing values can be found by using <code>.sum()</code> to add up the number of occurrences of <code>True</code> in the series. This shows that there are 2 missing values. </p><p>To find the row where the missing values occur, we can create a subset of the DataFrame using <code>.isna()</code> once again (If you've arrived at this answer using a different approach, that's fine too. There are a number of ways to solve this challenge.) </p><figure><img src="https://img-c.udemycdn.com/redactor/raw/2020-10-10_10-39-35-0b1e488850a4c761254ddbe93fef69e0.png" style="width: 100%;"></figure><p>To remove a missing value we can use <code>.dropna()</code>. The <code>inplace</code> argument allows to overwrite our DataFrame and means we don't have to write:</p><pre class="prettyprint linenums">df_btc_price = df_btc_price.dropna()</pre><figure><img src="https://img-c.udemycdn.com/redactor/raw/2020-10-10_10-39-50-e1b4a0083a8499a5fe530202b1a60bd0.png" style="width: 100%;"></figure><h4>Challenge</h4><p><br></p><p>Our DataFrames contain time-series data. Do you remember how to check the data type of the entries in the DataFrame?&nbsp;Have a look at the data types of the MONTH or DATE columns. Convert any strings you find into <code>Datetime</code> objects. Do this for all 4 DataFrames. Double-check if your type conversion was successful.</p><p>.</p><p>.</p><p>..</p><p>...</p><p>..</p><p>.</p><p>.</p><p><strong>Solution:&nbsp;Converting Strings to DateTime Objects</strong></p><p>All the date data in our columns are in the form of strings. To convert this into a Datetime object we're going to use the Pandas <code>.to_datetime()</code> function. </p><pre class="prettyprint linenums">df_tesla.MONTH = pd.to_datetime(df_tesla.MONTH)
df_btc_search.MONTH = pd.to_datetime(df_btc_search.MONTH)
df_unemployment.MONTH = pd.to_datetime(df_unemployment.MONTH)
df_btc_price.DATE = pd.to_datetime(df_btc_price.DATE)</pre><figure><img src="https://img-c.udemycdn.com/redactor/raw/2020-10-10_10-40-14-4fb3d5f631ceaea60b7dc9f2de1ec533.png" style="width: 100%;"></figure><p><br></p><h4>Resampling Time Series Data</h4><p>Next, we have to think about how to make our Bitcoin price and our Bitcoin search volume comparable. Our Bitcoin price is daily data, but our Bitcoin Search Popularity is monthly data. </p><p>To convert our daily data into monthly data, we're going to use the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html" rel="noopener noreferrer" target="_blank">.resample()</a> function. The only things we need to specify is which column to use (i.e., our DATE column)&nbsp;and what kind of sample frequency we want (i.e., the "rule"). We want a monthly frequency, so we use <code>'M'</code>.&nbsp; If you ever need to resample a time series to a different frequency, you can find a list of different options <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects" rel="noopener noreferrer" target="_blank">here</a> (for example <code>'Y'</code> for yearly or <code>'T'</code> for minute).</p><p>After resampling, we need to figure out how the data should be treated. In our case, we want the last available price of the month - the price at month-end.</p><pre class="prettyprint linenums">df_btc_monthly = df_btc_price.resample('M', on='DATE').last()</pre><p>If we wanted the average price over the course of the month, we could use something like:</p><pre class="prettyprint linenums">df_btc_monthly = df_btc_price.resample('M', on='DATE').mean()</pre><p>This is what our data looks like now:</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/2020-10-10_10-40-46-fb7f0593d8a82bf84479c5f1a4615b9a.png" style="width: 100%;"></figure><p>We have 73 rows in our price data - the same as our search data. Nice! </p>